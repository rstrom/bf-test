{"version":3,"sources":["../src/parsers/sitemap-parser.ts","../src/schemas/sitemap-schema.ts","../src/handlers/butterfly-handler.ts"],"sourcesContent":["import { XMLParser } from \"fast-xml-parser\";\nimport { Effect, Schema, Data } from \"effect\";\nimport { Sitemap, SitemapPipeline, SitemapMatch, SitemapAction } from \"../entities/sitemap\";\nimport { SitemapSchema } from \"../schemas/sitemap-schema\";\n\nexport class SitemapXmlParseError extends Data.TaggedError(\"SitemapXmlParseError\")<{\n  message: string;\n  cause?: Error;\n}> {}\n\nexport class SitemapValidationError extends Data.TaggedError(\"SitemapValidationError\")<{\n  message: string;\n  cause?: Error;\n}> {}\n\nexport class SitemapStructureError extends Data.TaggedError(\"SitemapStructureError\")<{\n  message: string;\n  missingElement: string;\n}> {}\n\nexport type SitemapParseError = SitemapXmlParseError | SitemapValidationError | SitemapStructureError;\n\nexport class SitemapParser {\n  private static parser = new XMLParser({\n    ignoreAttributes: false,\n    attributeNamePrefix: \"@_\",\n    textNodeName: \"#text\",\n  });\n\n  static parse = Effect.fn(\"SitemapParser/parse\")((xmlContent: string) =>\n    Effect.gen(function* () {\n      // Parse XML content\n      const rawSitemap = yield* Effect.try({\n        try: () => {\n          const parsed = SitemapParser.parser.parse(xmlContent);\n\n          if (!parsed[\"map:sitemap\"]) {\n            throw new SitemapStructureError({\n              message: \"Root element 'map:sitemap' not found\",\n              missingElement: \"map:sitemap\",\n            });\n          }\n\n          const sitemapElement = parsed[\"map:sitemap\"];\n          const pipelinesElement = sitemapElement[\"map:pipelines\"];\n\n          if (!pipelinesElement) {\n            throw new SitemapStructureError({\n              message: \"'map:pipelines' element not found\",\n              missingElement: \"map:pipelines\",\n            });\n          }\n\n          // Handle single pipeline or array of pipelines\n          const pipelineElements = Array.isArray(pipelinesElement[\"map:pipeline\"])\n            ? pipelinesElement[\"map:pipeline\"]\n            : [pipelinesElement[\"map:pipeline\"]];\n\n          const pipelines: SitemapPipeline[] = pipelineElements.map(SitemapParser.parsePipeline);\n\n          return { pipelines };\n        },\n        catch: (error) => {\n          if (error instanceof SitemapStructureError) {\n            return error;\n          }\n          return new SitemapXmlParseError({\n            message: `Failed to parse sitemap XML: ${error instanceof Error ? error.message : String(error)}`,\n            cause: error instanceof Error ? error : undefined,\n          });\n        },\n      });\n\n      // Validate the parsed sitemap against the schema\n      const validatedSitemap = yield* Schema.decodeUnknown(SitemapSchema)(rawSitemap).pipe(\n        Effect.catchAll((error) =>\n          Effect.fail(\n            new SitemapValidationError({\n              message: `Sitemap validation failed: ${error.message}`,\n              cause: error instanceof Error ? error : undefined,\n            }),\n          ),\n        ),\n      );\n\n      return validatedSitemap;\n    }),\n  );\n\n  private static parsePipeline(pipelineElement: any): SitemapPipeline {\n    if (!pipelineElement[\"map:match\"]) {\n      return { matches: [] };\n    }\n\n    // Handle single match or array of matches\n    const matchElements = Array.isArray(pipelineElement[\"map:match\"])\n      ? pipelineElement[\"map:match\"]\n      : [pipelineElement[\"map:match\"]];\n\n    const matches: SitemapMatch[] = matchElements.map(SitemapParser.parseMatch);\n\n    return { matches };\n  }\n\n  private static parseMatch(matchElement: any): SitemapMatch {\n    const pattern = matchElement[\"@_pattern\"] || \"\";\n    let action: SitemapAction;\n\n    // Parse different action types\n    if (matchElement[\"map:read\"]) {\n      const readElement = matchElement[\"map:read\"];\n      action = {\n        type: \"read\",\n        src: readElement[\"@_src\"],\n        rangeSupport: readElement[\"@_rangeSupport\"] === \"true\",\n      };\n    } else if (matchElement[\"map:generate\"]) {\n      action = {\n        type: \"generate\",\n        generator: matchElement[\"map:generate\"][\"@_generator\"],\n      };\n    } else if (matchElement[\"map:transform\"]) {\n      action = {\n        type: \"transform\",\n        transformer: matchElement[\"map:transform\"][\"@_transformer\"],\n        src: matchElement[\"map:transform\"][\"@_src\"],\n      };\n    } else {\n      // Default to read action with pattern as src\n      action = {\n        type: \"read\",\n        src: pattern,\n        rangeSupport: false,\n      };\n    }\n\n    return { pattern, action };\n  }\n\n  /**\n   * Generate default sitemap that matches current AssetName behavior\n   */\n  static generateDefaultSitemap(): Sitemap {\n    return {\n      pipelines: [\n        {\n          matches: [\n            // Root index handling\n            {\n              pattern: \"\",\n              action: { type: \"read\", src: \"index.html\" },\n            },\n            // Directory index handling\n            {\n              pattern: \"**/\",\n              action: { type: \"read\", src: \"{1}/index.html\" },\n            },\n            // Video files with range support (must come before general file handling)\n            {\n              pattern: \"**.mp4\",\n              action: { type: \"read\", src: \"{0}\", rangeSupport: true },\n            },\n            {\n              pattern: \"**.webm\",\n              action: { type: \"read\", src: \"{0}\", rangeSupport: true },\n            },\n            {\n              pattern: \"**.mov\",\n              action: { type: \"read\", src: \"{0}\", rangeSupport: true },\n            },\n            {\n              pattern: \"**.avi\",\n              action: { type: \"read\", src: \"{0}\", rangeSupport: true },\n            },\n            {\n              pattern: \"**.mkv\",\n              action: { type: \"read\", src: \"{0}\", rangeSupport: true },\n            },\n            // Explicit file handling (must come before ** to avoid conflicts)\n            {\n              pattern: \"**.*\",\n              action: { type: \"read\", src: \"{0}\" },\n            },\n            // HTML extension handling\n            {\n              pattern: \"**\",\n              action: { type: \"read\", src: \"{1}.html\" },\n            },\n          ],\n        },\n      ],\n    };\n  }\n}\n","import { Schema } from \"effect\";\n\n/**\n * Effect Schema definitions for Butterfly sitemap validation.\n * These schemas provide runtime validation and type safety for sitemap configurations.\n */\n\n// Base action types\nexport const SitemapActionType = Schema.Literal(\"read\", \"generate\", \"transform\");\n\n// Read action schema\nexport const ReadActionSchema = Schema.Struct({\n  type: Schema.Literal(\"read\"),\n  src: Schema.String.pipe(Schema.minLength(1, { message: () => \"src attribute cannot be empty\" })),\n  rangeSupport: Schema.optional(Schema.Boolean),\n}).pipe(\n  Schema.annotations({\n    identifier: \"ReadAction\",\n    title: \"Read Action\",\n    description: \"Action to serve a static asset with optional range support\",\n  }),\n);\n\n// Generate action schema\nexport const GenerateActionSchema = Schema.Struct({\n  type: Schema.Literal(\"generate\"),\n  generator: Schema.String.pipe(Schema.minLength(1, { message: () => \"generator attribute cannot be empty\" })),\n}).pipe(\n  Schema.annotations({\n    identifier: \"GenerateAction\",\n    title: \"Generate Action\",\n    description: \"Action to dynamically generate content using a specified generator\",\n  }),\n);\n\n// Transform action schema\nexport const TransformActionSchema = Schema.Struct({\n  type: Schema.Literal(\"transform\"),\n  src: Schema.String.pipe(Schema.minLength(1, { message: () => \"src attribute cannot be empty\" })),\n  transformer: Schema.String.pipe(Schema.minLength(1, { message: () => \"transformer attribute cannot be empty\" })),\n}).pipe(\n  Schema.annotations({\n    identifier: \"TransformAction\",\n    title: \"Transform Action\",\n    description: \"Action to transform content from a source asset through a specified transformer\",\n  }),\n);\n\n// Union of all action types\nexport const SitemapActionSchema = Schema.Union(ReadActionSchema, GenerateActionSchema, TransformActionSchema).pipe(\n  Schema.annotations({\n    identifier: \"SitemapAction\",\n    title: \"Sitemap Action\",\n    description: \"Action to take when a pattern matches a request\",\n  }),\n);\n\n// Pattern validation - basic glob pattern support\nconst PatternSchema = Schema.String.pipe(\n  Schema.annotations({\n    title: \"Pattern\",\n    description: \"Glob-style pattern to match against request paths. Supports **, *, and capture groups\",\n  }),\n);\n\n// Sitemap match schema\nexport const SitemapMatchSchema = Schema.Struct({\n  pattern: PatternSchema,\n  action: SitemapActionSchema,\n}).pipe(\n  Schema.annotations({\n    identifier: \"SitemapMatch\",\n    title: \"Sitemap Match\",\n    description: \"Pattern and action pair for request routing\",\n  }),\n);\n\n// Sitemap pipeline schema\nexport const SitemapPipelineSchema = Schema.Struct({\n  matches: Schema.Array(SitemapMatchSchema).pipe(\n    Schema.annotations({\n      description: \"Array of pattern matches processed in order\",\n    }),\n  ),\n}).pipe(\n  Schema.annotations({\n    identifier: \"SitemapPipeline\",\n    title: \"Sitemap Pipeline\",\n    description: \"Container for a sequence of pattern matches\",\n  }),\n);\n\n// Root sitemap schema\nexport const SitemapSchema = Schema.Struct({\n  pipelines: Schema.Array(SitemapPipelineSchema).pipe(\n    Schema.minItems(1, { message: () => \"At least one pipeline is required\" }),\n    Schema.annotations({\n      description: \"Array of pipelines containing routing rules\",\n    }),\n  ),\n}).pipe(\n  Schema.annotations({\n    identifier: \"Sitemap\",\n    title: \"Butterfly Sitemap\",\n    description: \"Root sitemap configuration for request routing\",\n  }),\n);\n\n// Route match result schema\nexport const RouteMatchSchema = Schema.Struct({\n  matched: Schema.Boolean,\n  assetPath: Schema.optional(Schema.String),\n  action: Schema.optional(SitemapActionSchema),\n}).pipe(\n  Schema.annotations({\n    identifier: \"RouteMatch\",\n    title: \"Route Match Result\",\n    description: \"Result of matching a request against sitemap patterns\",\n  }),\n);\n\n// Export inferred types\nexport type SitemapActionType = Schema.Schema.Type<typeof SitemapActionType>;\nexport type ReadAction = Schema.Schema.Type<typeof ReadActionSchema>;\nexport type GenerateAction = Schema.Schema.Type<typeof GenerateActionSchema>;\nexport type TransformAction = Schema.Schema.Type<typeof TransformActionSchema>;\nexport type SitemapAction = Schema.Schema.Type<typeof SitemapActionSchema>;\nexport type SitemapMatch = Schema.Schema.Type<typeof SitemapMatchSchema>;\nexport type SitemapPipeline = Schema.Schema.Type<typeof SitemapPipelineSchema>;\nexport type Sitemap = Schema.Schema.Type<typeof SitemapSchema>;\nexport type RouteMatch = Schema.Schema.Type<typeof RouteMatchSchema>;\n\n// Schemas are already exported above with their definitions\n","import { Effect, Option, Either } from \"effect\";\nimport { SitemapRouter } from \"../services/sitemap-router\";\nimport { SitemapParser } from \"../parsers/sitemap-parser\";\nimport { AssetLoader, AssetNotFoundError } from \"../services/asset-loader\";\nimport { Sitemap, RouteMatch } from \"../entities/sitemap\";\n\nexport interface SitemapValidationInfo {\n  success: boolean;\n  errors?: string[];\n}\n\nexport interface ButterflyHandlerResult {\n  matched: boolean;\n  assetPath?: string;\n  rangeSupport?: boolean;\n  fallbackToDefault?: boolean;\n  sitemapValidation?: SitemapValidationInfo;\n}\n\nexport class ButterflyHandler {\n  static process = Effect.fn(\"ButterflyHandler/process\")((pathname: string) =>\n    Effect.gen(function* () {\n      // Try to load custom sitemap from assets\n      const assetLoader = yield* AssetLoader;\n      const maybeSitemapXml = yield* assetLoader.loadAsset(\".moneta/sitemap.xml\").pipe(\n        Effect.map(Option.some),\n        Effect.catchTags({\n          AssetNotFoundError: () => Effect.succeed(Option.none<string>()),\n        }),\n      );\n\n      // Parse sitemap or use default, using functional Either pattern\n      const sitemapResult = yield* Option.match(maybeSitemapXml, {\n        onNone: () =>\n          Effect.succeed({\n            sitemap: SitemapParser.generateDefaultSitemap(),\n            validation: undefined as SitemapValidationInfo | undefined,\n          }),\n        onSome: (sitemapXml) =>\n          SitemapParser.parse(sitemapXml).pipe(\n            Effect.either,\n            Effect.flatMap((either) =>\n              Either.match(either, {\n                onLeft: (error) =>\n                  Effect.gen(function* () {\n                    yield* Effect.logWarning(\"Sitemap parsing failed, falling back to default\", error.message);\n                    return {\n                      sitemap: SitemapParser.generateDefaultSitemap(),\n                      validation: { success: false, errors: [error.message] } as SitemapValidationInfo,\n                    };\n                  }),\n                onRight: (sitemap) =>\n                  Effect.succeed({\n                    sitemap,\n                    validation: { success: true } as SitemapValidationInfo,\n                  }),\n              }),\n            ),\n          ),\n      });\n\n      const { sitemap, validation: sitemapValidation } = sitemapResult;\n\n      // Match the request against the sitemap\n      const routeMatch = yield* SitemapRouter.matchRequest(pathname, sitemap);\n\n      // Early return pattern using if/else with cleaner structure\n      if (!routeMatch.matched) {\n        return {\n          matched: false,\n          fallbackToDefault: true,\n          sitemapValidation,\n        };\n      }\n\n      return {\n        matched: true,\n        assetPath: routeMatch.assetPath,\n        rangeSupport: routeMatch.action?.type === \"read\" ? routeMatch.action.rangeSupport : false,\n        fallbackToDefault: false,\n        sitemapValidation,\n      };\n    }),\n  );\n}\n"],"mappings":"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","names":["Schema","Schema","Effect","Effect","sitemap"]}