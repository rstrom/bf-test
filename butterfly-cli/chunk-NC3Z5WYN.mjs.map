{"version":3,"sources":["../src/parsers/pattern-matcher.ts","../src/services/sitemap-router.ts","../src/services/asset-loader.ts"],"sourcesContent":["import { Option } from \"effect\";\n\nexport interface MatchResult {\n  substitutions: string[];\n}\n\nexport class PatternMatcher {\n  /**\n   * Match a path against a Cocoon-style pattern\n   * Supports:\n   * - * for single path segment wildcard\n   * - ** for multi-segment wildcard\n   * - Literal text matching\n   */\n  static match(path: string, pattern: string): Option.Option<MatchResult> {\n    // Handle exact match for empty patterns\n    if (pattern === \"\" && path === \"\") {\n      return Option.some({ substitutions: [path] });\n    }\n\n    if (pattern === \"\" || path === \"\") {\n      return Option.none();\n    }\n\n    // Convert Cocoon pattern to regex\n    const regexPattern = this.patternToRegex(pattern);\n    const regex = new RegExp(`^${regexPattern}$`);\n\n    const match = path.match(regex);\n\n    return Option.fromNullable(match).pipe(\n      Option.map((regexMatch) => {\n        // Extract substitution groups (full match + capture groups)\n        // For exact pattern matches without wildcards, return just the full match\n        if (regexMatch.length === 1) {\n          return {\n            substitutions: [regexMatch[0]],\n          };\n        }\n\n        // Include full match as {0} and capture groups as {1}, {2}, etc.\n        return {\n          substitutions: regexMatch.slice(0),\n        };\n      }),\n    );\n  }\n\n  /**\n   * Replace {n} placeholders in a string with substitution values\n   */\n  static substitute(template: string, originalPath: string, substitutions: string[]): string {\n    return template.replace(/\\{(\\d+)\\}/g, (match, index) => {\n      const idx = parseInt(index, 10);\n      return substitutions[idx] !== undefined ? substitutions[idx] : match;\n    });\n  }\n\n  private static patternToRegex(pattern: string): string {\n    // Escape regex special characters except * and **\n    let escaped = pattern\n      .replace(/[.+^${}()|[\\]\\\\]/g, \"\\\\$&\")\n      .replace(/\\*\\*/g, \"___DOUBLESTAR___\")\n      .replace(/\\*/g, \"___SINGLESTAR___\");\n\n    // Replace placeholders with regex groups\n    escaped = escaped\n      .replace(/___DOUBLESTAR___/g, \"(.*)\") // ** matches anything including /\n      .replace(/___SINGLESTAR___/g, \"([^/]*)\"); // * matches anything except /\n\n    return escaped;\n  }\n}\n","import { Effect, Option } from \"effect\";\nimport { Sitemap, RouteMatch } from \"../entities/sitemap\";\nimport { PatternMatcher } from \"../parsers/pattern-matcher\";\n\nexport class SitemapRouter {\n  static matchRequest = Effect.fn(\"SitemapRouter/matchRequest\")((pathname: string, sitemap: Sitemap) =>\n    Effect.sync(() => {\n      // Clean the pathname - remove leading slash for pattern matching\n      const cleanPath = pathname.startsWith(\"/\") ? pathname.slice(1) : pathname;\n\n      // Process pipelines in order\n      for (const pipeline of sitemap.pipelines) {\n        for (const match of pipeline.matches) {\n          const maybeResult = PatternMatcher.match(cleanPath, match.pattern);\n\n          // Use Option.match for cleaner conditional logic\n          const matchResult = Option.match(maybeResult, {\n            onNone: () => null,\n            onSome: (result) => {\n              // Apply substitutions to the action source\n              let assetPath: string;\n              if (match.action.type === \"read\") {\n                assetPath = PatternMatcher.substitute(match.action.src, cleanPath, result.substitutions);\n              } else if (match.action.type === \"transform\") {\n                assetPath = PatternMatcher.substitute(match.action.src, cleanPath, result.substitutions);\n              } else {\n                assetPath = cleanPath;\n              }\n\n              return {\n                matched: true,\n                assetPath,\n                action: match.action,\n              } as const;\n            },\n          });\n\n          if (matchResult) {\n            return matchResult;\n          }\n        }\n      }\n\n      // No match found\n      return {\n        matched: false,\n      } as const;\n    }),\n  );\n}\n","import { Context, Effect, Stream, Data } from \"effect\";\n\nexport class AssetNotFoundError extends Data.TaggedError(\"AssetNotFoundError\")<{\n  path: string;\n}> {\n  get message() {\n    return `Asset not found: ${this.path}`;\n  }\n}\n\nexport class AssetLoadError extends Data.TaggedError(\"AssetLoadError\")<{\n  path: string;\n  cause?: Error;\n}> {\n  get message() {\n    return `Failed to load asset: ${this.path}${this.cause ? ` - ${this.cause.message}` : \"\"}`;\n  }\n}\n\nexport class AssetStreamError extends Data.TaggedError(\"AssetStreamError\")<{\n  path: string;\n  cause?: Error;\n}> {\n  get message() {\n    return `Failed to stream asset: ${this.path}${this.cause ? ` - ${this.cause.message}` : \"\"}`;\n  }\n}\n\nexport type AssetError = AssetNotFoundError | AssetLoadError | AssetStreamError;\n\n/**\n * AssetLoader service for loading assets with full streaming and range request support.\n * This is the core dependency injection interface for Butterfly routing.\n */\nexport interface AssetStreamResult {\n  readonly stream: Stream.Stream<Uint8Array, AssetStreamError>;\n  readonly mimeType: string;\n}\n\nexport interface AssetRangeResult {\n  readonly stream: Stream.Stream<Uint8Array, AssetStreamError>;\n  readonly mimeType: string;\n  readonly contentLength: number;\n  readonly totalSize: number;\n}\n\nexport interface AssetLoaderService {\n  /**\n   * Load an asset as a string (for parsing sitemap.xml, text files, etc.)\n   * Implementations may have dependencies - these will be provided by the consumer\n   */\n  readonly loadAsset: (path: string) => Effect.Effect<string, AssetError, any>;\n\n  /**\n   * Load an asset as a stream with MIME type information\n   * Implementations may have dependencies - these will be provided by the consumer\n   */\n  readonly loadAssetStream: (path: string) => Effect.Effect<AssetStreamResult, AssetError, any>;\n\n  /**\n   * Load a byte range from an asset (required for video streaming)\n   * Implementations may have dependencies - these will be provided by the consumer\n   */\n  readonly loadAssetRange: (\n    path: string,\n    range: { start: number; end?: number },\n  ) => Effect.Effect<AssetRangeResult, AssetError, any>;\n}\n\nexport class AssetLoader extends Context.Tag(\"ButterflyAssetLoader\")<AssetLoader, AssetLoaderService>() {}\n"],"mappings":"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","names":["Option","Option"]}